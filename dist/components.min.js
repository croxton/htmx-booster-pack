var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value), value);
class HtmxComponent {
  constructor(element = "", options = {}) {
    __publicField(this, "mounted", !1);
    __publicField(this, "elm", null);
    __publicField(this, "target", null);
    __publicField(this, "_state", {});
    this._options = options || {}, element && (this.elm = element);
  }
  get options() {
    return this._options;
  }
  set options(defaults) {
    let options = {};
    if (this.elm) {
      let mount = document.querySelector(this.elm);
      if (mount) {
        let optionsFromAttribute = mount.dataset.options;
        optionsFromAttribute && (options = JSON.parse(optionsFromAttribute)), mount = null;
      }
    }
    this._options = {
      ...this._options,
      ...defaults,
      ...options
    };
  }
  mount() {
  }
  unmount() {
  }
  refresh() {
    this.unmount(), this.mount();
  }
  get state() {
    return console.warn("You should not get state manually. Use getState() instead."), this._state;
  }
  set state(state) {
    console.warn("You should not change state manually. Use setState() instead."), this._state = state;
  }
  setState(scope = "local", changes) {
    let stateChanges = {}, stateRef = this._state;
    scope === "global" ? stateRef = HtmxComponent._globalState : scope === "component" && (HtmxComponent._globalState.hasOwnProperty(this.constructor.name) || (HtmxComponent._globalState[this.constructor.name] = {}), stateRef = HtmxComponent._globalState[this.constructor.name]), Object.keys(changes).forEach((key) => {
      Array.isArray(changes[key]) ? stateRef[key] != null && Array.isArray(stateRef[key]) && stateRef[key].length === changes[key].length ? changes[key].some((item, index) => stateRef[key][index] !== item ? (stateChanges[key] = changes[key], stateRef[key] = stateChanges[key], !0) : !1) : (stateChanges[key] = changes[key], stateRef[key] = stateChanges[key]) : typeof changes[key] == "object" ? (stateRef[key] != null && typeof stateRef[key] == "object" ? (stateChanges[key] = {}, Object.keys(changes[key]).forEach((subkey) => {
        stateRef[key][subkey] !== changes[key][subkey] && (stateChanges[key][subkey] = changes[key][subkey]);
      })) : stateChanges[key] = changes[key], stateRef[key] = {
        ...stateRef[key],
        ...stateChanges[key]
      }) : stateRef !== changes[key] && (stateChanges[key] = changes[key], stateRef[key] = changes[key]);
    }), Object.keys(stateChanges).forEach((key) => {
      Array.isArray(changes[key]) ? stateChanges[key].length === 0 && delete stateChanges[key] : typeof changes[key] == "object" && Object.keys(stateChanges[key]).length === 0 && delete stateChanges[key];
    }), stateRef = null, this.stateChange(stateChanges);
  }
  stateChange(stateChanges, original) {
  }
  getState(scope = "local", defaults = {}) {
    let stateRef = this._state;
    return scope === "global" ? stateRef = HtmxComponent._globalState : scope === "component" && (HtmxComponent._globalState.hasOwnProperty(this.constructor.name) ? stateRef = HtmxComponent._globalState[this.constructor.name] : stateRef = {}), {
      ...defaults,
      ...stateRef
    };
  }
  destroyState(scope = "local") {
    scope === "global" ? HtmxComponent._globalState = {} : scope === "component" ? HtmxComponent._globalState.hasOwnProperty(this.constructor.name) && (HtmxComponent._globalState[this.constructor.name] = {}) : this._state = {};
  }
  css(urls) {
    return Promise.all(urls.map(this._loadCSS));
  }
  _loadCSS(href) {
    return new Promise((resolve) => {
      if (HtmxComponent._sheets.includes(href))
        return resolve();
      HtmxComponent._sheets.push(href);
      let link = document.createElement("link");
      link.type = "text/css", link.rel = "stylesheet", link.onload = resolve, link.setAttribute("href", href), document.head.appendChild(link);
    });
  }
}
Object.defineProperty(HtmxComponent, "_sheets", {
  value: [],
  writable: !0
});
Object.defineProperty(HtmxComponent, "_globalState", {
  value: {},
  writable: !0
});
(function() {
  let config = {
    origin: location.origin,
    basePath: "scripts/components"
  }, configMeta = document.querySelector('meta[name="htmx-components-config"]') ?? null;
  configMeta && (config = {
    ...config,
    ...JSON.parse(configMeta.content)
  }), config.basePath = config.basePath.replace(/^\/|\/$/g, "");
  const strategies = {
    event: (requirement) => new Promise((resolve) => {
      let topic;
      if (requirement.indexOf("(") !== -1) {
        const topicStart = requirement.indexOf("(") + 1;
        topic = requirement.slice(topicStart, -1);
      }
      topic ? document.body.addEventListener(
        topic,
        () => {
          resolve();
        },
        { once: !0 }
      ) : resolve();
    }),
    idle: () => new Promise((resolve) => {
      "requestIdleCallback" in window ? window.requestIdleCallback(resolve) : setTimeout(resolve, 200);
    }),
    media: (requirement) => new Promise((resolve) => {
      const queryStart = requirement.indexOf("("), query = requirement.slice(queryStart), mediaQuery = window.matchMedia(query);
      mediaQuery.matches ? resolve() : mediaQuery.addEventListener("change", resolve, { once: !0 });
    }),
    visible: (selector = null, requirement) => selector ? new Promise((resolve) => {
      let rootMargin = "0px 0px 0px 0px";
      if (requirement.indexOf("(") !== -1) {
        const rootMarginStart = requirement.indexOf("(") + 1;
        rootMargin = requirement.slice(rootMarginStart, -1);
      }
      const observer = new IntersectionObserver(
        (entries) => {
          entries[0].isIntersecting && (observer.disconnect(), resolve());
        },
        { rootMargin }
      );
      let elm = document.querySelector(selector);
      elm ? observer.observe(elm) : resolve();
    }) : Promise.resolve(!0)
  };
  function loadStrategies(strategy, selector) {
    let promises = [];
    if (strategy) {
      let requirements = strategy.split("|").map((requirement) => requirement.trim()).filter((requirement) => requirement !== "immediate").filter((requirement) => requirement !== "eager");
      for (let requirement of requirements) {
        if (requirement.startsWith("event")) {
          promises.push(strategies.event(requirement));
          continue;
        }
        if (requirement === "idle") {
          promises.push(strategies.idle());
          continue;
        }
        if (requirement.startsWith("media")) {
          promises.push(strategies.media(requirement));
          continue;
        }
        requirement.startsWith("visible") && promises.push(strategies.visible(selector, requirement));
      }
    }
    return promises;
  }
  class componentFactory extends HtmxComponent {
    constructor() {
      super();
      __publicField(this, "loaded", []);
      this.mount();
    }
    mount() {
      let targetId = htmx.config.currentTargetId ?? "main", target = document.getElementById(targetId);
      if (target) {
        let components = target.querySelectorAll("[data-component]");
        for (let el of components)
          this.lazyload(el);
        target = null, components = null;
      }
    }
    unmount() {
      let targetId = htmx.config.currentTargetId ?? "main", target = document.getElementById(targetId);
      if (target) {
        for (let i = this.loaded.length - 1; i >= 0; i--) {
          let inTarget = target.querySelector(this.loaded[i].selector), inDocument = document.querySelector(this.loaded[i].selector);
          (inTarget || !inDocument) && (this.loaded[i].instance.unmount(), this.loaded.splice(i, 1));
        }
        target = null;
      }
    }
    /**
     * Import a component on demand, optionally using a loading strategy
     *
     * @param el
     */
    lazyload(el) {
      let component = el.dataset.component, version = el.dataset.version ?? "1", strategy = el.dataset.load ?? null, selector = el.getAttribute("id") ? "#" + el.getAttribute("id") : '[data-component="' + component + '"]', promises = loadStrategies(strategy, selector);
      Promise.all(promises).then(() => {
        import(
          /* @vite-ignore */
          `${config.origin}/${config.basePath}/${component}.js?v=${version}`
        ).then(
          (lazyComponent) => {
            let instance = new lazyComponent.default(selector);
            instance.mounted = !0, this.loaded.push({
              name: component,
              selector,
              instance
            });
          }
        );
      });
    }
  }
  let cache = {
    now: {},
    next: {}
  };
  function saveToCache(dom, store) {
    let markers = dom.querySelectorAll('[data-component]:not([data-reset="false"])');
    if (markers)
      for (let i = 0; i < markers.length; ++i)
        typeof markers[i].id < "u" && (cache[store][markers[i].id] = markers[i].outerHTML);
  }
  function rotateCache() {
    let prunedCache = {};
    for (let key in cache.now) {
      let el = document.getElementById(key);
      el && (prunedCache[key] = cache.now[key]), el = null;
    }
    cache.now = prunedCache, Object.keys(cache.next).length > 0 && (cache.now = {
      ...cache.now,
      ...cache.next
    }, cache.next = {});
  }
  let factory;
  htmx.defineExtension("components", {
    init: function() {
      factory = new componentFactory(), factory.mounted = !0, saveToCache(document, "now");
    },
    onEvent: function(name, htmxEvent) {
      var _a, _b;
      if (name === "htmx:beforeSwap") {
        let incomingDOM = new DOMParser().parseFromString(
          htmxEvent.detail.xhr.response,
          "text/html"
        );
        incomingDOM && saveToCache(incomingDOM, "next"), incomingDOM = null;
      }
      if (name === "htmx:afterSwap" && (htmx.config.currentTargetId = htmxEvent.target.id, factory.refresh()), name === "htmx:historyItemCreated" && htmxEvent.detail.item.content) {
        let cachedDOM = new DOMParser().parseFromString(
          htmxEvent.detail.item.content,
          "text/html"
        );
        for (let key in cache.now) {
          let el = cachedDOM.getElementById(key);
          el && (el.outerHTML = cache.now[key]), el = null;
        }
        htmxEvent.detail.item.content = cachedDOM.body.innerHTML, rotateCache();
      }
      if (name === "htmx:historyRestore") {
        htmx.config.currentTargetId = null, factory.refresh();
        let restored = (_b = (_a = htmxEvent == null ? void 0 : htmxEvent.detail) == null ? void 0 : _a.item) == null ? void 0 : _b.content;
        if (restored) {
          let restoredDOM = new DOMParser().parseFromString(
            restored,
            "text/html"
          );
          restoredDOM && saveToCache(restoredDOM, "now");
        }
      }
    }
  });
})();
(function() {
  Element.prototype._addEventListener = Element.prototype.addEventListener, Element.prototype._removeEventListener = Element.prototype.removeEventListener, Element.prototype.addEventListener = function(type, listener, useCapture = !1) {
    this._addEventListener(type, listener, useCapture), this.eventListenerList || (this.eventListenerList = {}), this.eventListenerList[type] || (this.eventListenerList[type] = []), this.eventListenerList[type].push({ type, listener, useCapture });
  }, Element.prototype.removeEventListener = function(type, listener, useCapture = !1) {
    this._removeEventListener(type, listener, useCapture), this.eventListenerList || (this.eventListenerList = {}), this.eventListenerList[type] || (this.eventListenerList[type] = []);
    for (let i = 0; i < this.eventListenerList[type].length; i++)
      if (this.eventListenerList[type][i].listener === listener && this.eventListenerList[type][i].useCapture === useCapture) {
        this.eventListenerList[type].splice(i, 1);
        break;
      }
    this.eventListenerList[type].length === 0 && delete this.eventListenerList[type];
  }, Element.prototype.getEventListeners = function(type) {
    return this.eventListenerList || (this.eventListenerList = {}), type === void 0 ? this.eventListenerList : this.eventListenerList[type];
  }, Element.prototype.clearEventListeners = function(a) {
    if (this.eventListenerList || (this.eventListenerList = {}), a === void 0) {
      for (let x in this.getEventListeners())
        this.clearEventListeners(x);
      return;
    }
    const el = this.getEventListeners(a);
    if (el !== void 0)
      for (let i = el.length - 1; i >= 0; --i) {
        let ev = el[i];
        this.removeEventListener(a, ev.listener, ev.useCapture);
      }
  };
})();
